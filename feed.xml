<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Elena Pagnin</title>
    <description>Elena Pagnin Assistant Professor in Cryptography @ CRYPSY lab (LTH)
</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 28 Apr 2021 13:45:56 +0200</pubDate>
    <lastBuildDate>Wed, 28 Apr 2021 13:45:56 +0200</lastBuildDate>
    <generator>Jekyll v3.7.0</generator>
    
      <item>
        <title>Things you should know</title>
        <description>&lt;p&gt;This post contains some common Q&amp;amp;A for PhD students:&lt;/p&gt;

&lt;h2 id=&quot;q-am-i-allowed-to-submit-the-same-paper-to-multiple-venues&quot;&gt;Q: Am I allowed to submit the same paper to multiple venues?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; In general NO, not simultaneously. 
The large majority of the conferences and journals in our filed only accept original works (i.e., papers that do not have large overlap with existing work). 
If your paper is rejected from venue1, of course you can submit (an improved version) to venue2, after you receive the final notification of rejection. 
&lt;strong&gt;Always read the call for papers (CFP) in detail&lt;/strong&gt;, especially if you are a novice. 
There are a few exceptions: some journals, local conferences without proceedings and workshops accept works that have already been published or ‘full version’ (usually at least 25% new material) of existing publications.&lt;/p&gt;

</description>
        <pubDate>Tue, 27 Apr 2021 12:00:00 +0200</pubDate>
        <link>/publications/2021/phd-Q&A</link>
        <guid isPermaLink="true">/publications/2021/phd-Q&A</guid>
        
        
        <category>phds</category>
        
      </item>
    
      <item>
        <title>4 LaTeX</title>
        <description>&lt;h2 id=&quot;handy-links-for-latex&quot;&gt;Handy links for LaTeX&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://detexify.kirelabs.org&quot;&gt;Detexify&lt;/a&gt; automatic recognition of handwritten symbols&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 27 Apr 2021 12:00:00 +0200</pubDate>
        <link>/publications/2021/latex</link>
        <guid isPermaLink="true">/publications/2021/latex</guid>
        
        
        <category>tricks</category>
        
      </item>
    
      <item>
        <title>GIT &amp;co</title>
        <description>&lt;h2 id=&quot;handy-links-for-git&quot;&gt;Handy links for GIT&lt;/h2&gt;

&lt;p&gt;Git is an amazing tool for collaborative projects. 
In a nutshell, it enables version controlling of whatever collection of digital you log in it. 
When writing a paper with other people, it makes it easy to trace changes, ensure everyone can reach the most recent version of the text / code / experiments, and revert back in time to restore previous versions, if needed. 
As a PhD student, if you want to do research with me, knowing how to navigate git is a prerequisite.&lt;/p&gt;

&lt;p&gt;There are several guides available on google as well as youtube tutorials. 
Find the ones that works best for you!&lt;/p&gt;

&lt;p&gt;Here’s a couple of links (feel free to PM me with better and more up to date suggestions!)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://dev.to/tauag/quick-start-guide-to-git-2of5&quot;&gt;Quick Start Guide to Git&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://rogerdudler.github.io/git-guide/&quot;&gt;git - the simple guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You are more than welcome to control the git report from the command line ;-) but, should you at some point want to use a GUI, &lt;a href=&quot;https://www.sourcetreeapp.com&quot;&gt;SourceTree&lt;/a&gt; is a great one (for mac and windows)&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Apr 2021 12:00:00 +0200</pubDate>
        <link>/publications/2021/git</link>
        <guid isPermaLink="true">/publications/2021/git</guid>
        
        
        <category>phds</category>
        
      </item>
    
      <item>
        <title>Yggdrasil: Privacy-aware Dual Deduplication in Multi Client Settings</title>
        <description>&lt;p&gt;&lt;em&gt;H.Sehat&lt;/em&gt;, &lt;strong&gt;E.Pagnin&lt;/strong&gt;, &lt;em&gt;D. Lucani&lt;/em&gt;
In IEEE International Conference on Communications
&lt;a href=&quot;https://arxiv.org/pdf/2007.11403.pdf&quot;&gt;Full Text&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;

&lt;p&gt;This paper proposes Yggdrasil, a protocol for privacy-aware dual data deduplication in multi client settings. Yggdrasil is designed to reduce the cloud storage space while safeguarding the privacy of the client’s outsourced data. Yggdrasil combines three innovative tools to achieve this goal. First, generalized deduplication, an emerging technique to reduce data footprint. Second, non-deterministic transformations that are described compactly and improve the degree of data compression in the Cloud (across users). Third, data preprocessing in the clients in the form of lightweight, privacy-driven transformations prior to upload. This guarantees that an honest-but-curious Cloud service trying to retrieve the client’s actual data will face a high degree of uncertainty as to what the original data is. We provide a mathematical analysis of the measure of uncertainty as well as the compression potential of our protocol. Our experiments with a HDFS log data set shows that 49 % overall compression can be achieved, with clients storing only 12 % for privacy and the Cloud storing the rest. This is achieved while ensuring that each fragment uploaded to the Cloud would have 10293 possible original strings from the client. Higher uncertainty is possible, with some reduction of compression potential.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Keywords:&lt;/strong&gt;
Compression, Privacy, Deduplication&lt;/p&gt;
</description>
        <pubDate>Thu, 15 Apr 2021 16:00:00 +0200</pubDate>
        <link>/publications/2021/yggrdasil</link>
        <guid isPermaLink="true">/publications/2021/yggrdasil</guid>
        
        
        <category>conference</category>
        
      </item>
    
      <item>
        <title>Where are you Bob? Privacy-Preserving Proximity Testing with a Napping Party</title>
        <description>&lt;p&gt;&lt;em&gt;I. Oleynikov&lt;/em&gt;, &lt;strong&gt;E. Pagnin&lt;/strong&gt;, &lt;em&gt;A. Sabelfeld&lt;/em&gt;
the 26th European Symposium on Research in Computer Security (ESORICS 2020).
&lt;a href=&quot;https://eprint.iacr.org/2020/857.pdf&quot;&gt;Full Text&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;

&lt;p&gt;Location based services (LBS) extensively utilize proximity testing to help people discover nearby friends, devices, and services. Current practices rely on full trust to the service providers: users share their locations with the providers who perform proximity testing on behalf of the users. Unfortunately, location data has been often breached by LBS providers, raising privacy concerns over the current practices. To address these concerns previous research has suggested cryptographic protocols for privacy-preserving location proximity testing. Yet general and precise location proximity testing has been out of reach for the current research. A major roadblock has been the requirement by much of the previous work that for proximity testing between Alice and Bob both must be present online. This requirement is not problematic for one-to-one proximity testing but it does not generalize to one-to-many testing. Indeed, in settings like ridesharing, it is desirable to match against ride preferences of all users, not necessarily ones that are currently online. This paper proposes a novel privacy-preserving proximity testing protocol where, after providing some data about its location, one party can go offline (nap) during the proximity testing execution, without undermining user privacy. We thus break away from the limitation of much of the previous work where the parties must be online and interact directly to each other to retain user privacy. Our basic protocol achieves privacy against semi-honest parties and can be upgraded to full security (against malicious parties) in a straight forward way using advanced cryptographic tools. Finally, we reduce the responding client overhead from quadratic (in the proximity radius parameter) to constant, com- pared to the previous research. Analysis and performance experiments with an implementation confirm our findings.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Keywords:&lt;/strong&gt;
Secure proximity testing, privacy-preserving location based services, MPC&lt;/p&gt;
</description>
        <pubDate>Wed, 16 Sep 2020 16:00:00 +0200</pubDate>
        <link>/publications/2020/olic</link>
        <guid isPermaLink="true">/publications/2020/olic</guid>
        
        
        <category>conference</category>
        
      </item>
    
      <item>
        <title>Secure Generalized Deduplication via Multi-Key Revealing Encryption</title>
        <description>&lt;p&gt;&lt;em&gt;D. Lucani, L. Nielsen, C. Orlandi,&lt;/em&gt; &lt;strong&gt;E. Pagnin&lt;/strong&gt;, and &lt;em&gt;R. Vestergaard&lt;/em&gt;
In Conference on Security and Cryptography for Networks (SCN), Amalfi, Italy 2020.
&lt;a href=&quot;https://eprint.iacr.org/2020/799.pdf&quot;&gt;Full Text&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;

&lt;p&gt;Cloud Storage Providers (CSPs) offer solutions to relieve users from locally storing vast amounts of data, including personal and sensitive ones. While users may desire to retain some privacy on the data they outsource, CSPs are interested in reducing the total storage space by employing compression techniques such as deduplication. We propose a new cryptographic primitive that simultaneously realizes both requirements: Multi-Key Revealing Encryption (MKRE). The goal of MKRE is to disclose the result of a predefined function over multiple ciphertexts, even if the ciphertexts were generated using different keys, while revealing nothing else about the data. We present a formal model and a security definition for MKRE and provide a construction of MKRE for generalized deduplication that only uses symmetric key primitives in a black-box way. Our construction allows (a) cloud providers to reduce the storage space by using generalized deduplication to compress encrypted data across users, and (b) each user to maintain a certain privacy level for the outsourced information. Our scheme can be proven secure in the random oracle model (and we argue that this is a necessary evil). We develop a proof-of-concept implementation of our solution. For a test data set, our MKRE construction achieves secure generalized deduplication with a compression ratio of 87% for 1KB file chunks and 82.2% for 8KB chunks. Finally, our experiments show that, compared to generalized deduplication setup with un-encrypted files, adding privacy via MKRE introduces a compression overhead of less than 3% and reduces the storage throughput by at most 6.9%.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Keywords:&lt;/strong&gt;
Multi-Key Revealing Encryption, Secure Storage, Generalized Data Deduplication.&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Sep 2020 16:00:00 +0200</pubDate>
        <link>/publications/2020/mkre</link>
        <guid isPermaLink="true">/publications/2020/mkre</guid>
        
        
        <category>conference</category>
        
      </item>
    
      <item>
        <title>TOPPool: time-aware optimized privacy-preserving ridesharing</title>
        <description>&lt;p&gt;&lt;strong&gt;E. Pagnin&lt;/strong&gt;, &lt;em&gt;G. Gunnarsson, P. Talebi, C. Orlandi, A. Sabelfeld&lt;/em&gt;
Proceedings on Privacy Enhancing Technologies (PETS 2019).
&lt;a href=&quot;https://petsymposium.org/2019/files/papers/issue4/popets-2019-0060.pdf&quot;&gt;Full Text&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;

&lt;p&gt;Ridesharing is revolutionizing the transporta- tion industry in many countries. Yet, the state of the art is based on heavily centralized services and platforms, where the service providers have full possession of the users’ location data. Recently, researchers have started addressing the challenge of enabling privacy-preserving ridesharing. The initial proposals, however, have shortcomings, as some rely on a central party, some incur high performance penalties, and most do not consider time preferences for ridesharing. TOPPool encompasses ridesharing based on the proximity of end-points of a ride as well as partial itinerary overlaps. To achieve the latter, we propose a simple yet powerful reduction to a private set intersection on trips represented as sets of consecutive road segments. We show that TOPPool includes time preferences while preserving privacy and without relying on a third party. We evaluate our approach on real-world data from the New York’s Taxi &amp;amp; Limousine Commission. Our experiments demonstrate that TOPPool is superior in performance over the prior work: our intersection-based itinerary matching runs in less than 0.3 seconds for reasonable trip length, in contrast, on the same set of trips prior work takes up to 10 hours.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Keywords:&lt;/strong&gt;
Privacy-preserving ride sharing, Location privacy, Private set intersection.&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Sep 2020 16:00:00 +0200</pubDate>
        <link>/publications/2020/toppool</link>
        <guid isPermaLink="true">/publications/2020/toppool</guid>
        
        
        <category>journal</category>
        
      </item>
    
      <item>
        <title>The simplest multi-key linearly homomorphic signature scheme</title>
        <description>&lt;p&gt;&lt;em&gt;D. Aranha&lt;/em&gt;, &lt;strong&gt;E. Pagnin&lt;/strong&gt;
Sixth International Conference on Cryptology and Information Security in Latin America, October 2019 
&lt;a href=&quot;https://www.researchgate.net/profile/Diego-Aranha/publication/335709839_The_Simplest_Multi-key_Linearly_Homomorphic_Signature_Scheme/links/5d7b50a1a6fdcc2f0f6039a4/The-Simplest-Multi-key-Linearly-Homomorphic-Signature-Scheme.pdf&quot;&gt;Full Text&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;We consider the problem of outsourcing computation on data authenticated by different users. Our aim is to describe and implement the simplest possible solution to provide data integrity in cloud-based scenarios. Concretely, our multi-key linearly homomorphic signature scheme (mklhs) allows users to upload signed data on a server, and at any later point in time any third party can query the server to compute a linear combination of data authenticated by different users and check the correctness of the returned result. Our construction generalizes Boneh et al.’s linearly homomorphic signature scheme (PKC’09 [7]) to the multi-key setting and relies on basic tools of pairing-based cryptography. Compared to existing multi-key homomorphic signature schemes, our mklhs is a conceptually simple and elegant direct construction, which trades-off privacy for efficiency. The simplicity of our approach leads us to a very efficient construction that enjoys significantly shorter signatures and higher performance than previous proposals. Finally, we implement mklhs using two different pairing-friendly curves at the 128-bit security level, a Barreto-Lynn-Scott curve and a Barreto-Naehrig curve. Our benchmarks illustrate interesting performance trade-offs between these parameters, involving the cost of exponentiation and hashing in pairing groups. We provide a discussion on such trade-offs that can be useful to other implementers of pairing-based protocols.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Keywords:&lt;/strong&gt;
Multi-key homomorphic signatures, cryptographic pairings, efficient software implementation.&lt;/p&gt;
</description>
        <pubDate>Sun, 04 Aug 2019 16:00:00 +0200</pubDate>
        <link>/publications/2019/the-simplest</link>
        <guid isPermaLink="true">/publications/2019/the-simplest</guid>
        
        
        <category>conference</category>
        
      </item>
    
      <item>
        <title>SAID: Reshaping Signal into an Identity-Based Asynchronous Messaging Protocol with Authenticated Ratcheting</title>
        <description>&lt;p&gt;&lt;em&gt;O. Blazy, A. Bossuat, X. Bultel, P. Fouque, C. Onete,&lt;/em&gt; &lt;strong&gt;E. Pagnin&lt;/strong&gt;
In EuroS&amp;amp;P 2019, Stockholm (Sweden), June 2019 
&lt;a href=&quot;https://eprint.iacr.org/2019/367.pdf&quot;&gt;Full Text&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;As messaging applications are becoming increasingly popular, it is of utmost importance to analyze their security and mitigate existing weaknesses. This paper focuses on one of the most acclaimed messaging applications: Signal. 
Signal is a protocol that provides end-to-end channel security, forward secrecy, and post-compromise security. These features are achieved thanks to a key-ratcheting mechanism that updates the key material at every message. Due to its high security impact, Signal’s key-ratcheting has recently been formalized, along with an analysis of its security. 
In this paper, we revisit Signal, describing some attacks against the original design and proposing SAID: Signal Authenticated and IDentity-based. As the name indicates, our protocol relies on an identity-based setup, which allows us to dispense with Signal’s centralized server. We use the identity-based long-term secrets to obtain persistent and explicit authentication, such that SAID achieves higher security guarantees than Signal. 
We prove the security of SAID not only in the Authenticated Key Exchange (AKE) model (as done by previous work), but also in the Authenticated and Confidential Channel Establishment (ACCE) model, which we adapted and redefined for SAID and asynchronous messaging protocols in general into a model we call identity-based Multistage Asynchronous Messaging (iMAM). We believe our model to be more faithful in particular to the true security of Signal, whose use of the message keys prevents them from achieving the composable guarantee claimed by previous analysis.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Keywords:&lt;/strong&gt;
Signal Protocol, Authenticated Ratchet, identity-based&lt;/p&gt;
</description>
        <pubDate>Fri, 07 Jun 2019 16:00:00 +0200</pubDate>
        <link>/publications/2019/said</link>
        <guid isPermaLink="true">/publications/2019/said</guid>
        
        
        <category>conference</category>
        
      </item>
    
      <item>
        <title>Multi-key homomorphic authenticators</title>
        <description>&lt;p&gt;&lt;em&gt;D. Fiore, A. Mitrokotsa, L. Nizzardo,&lt;/em&gt; &lt;strong&gt;E. Pagnin&lt;/strong&gt; 
In IET Information Security Journal, 2019.
&lt;a href=&quot;http://oa.upm.es/49539/1/INVE_MEM_2016_269602.pdf&quot;&gt;Full Text&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;

&lt;p&gt;Homomorphic authenticators (HAs) enable a client to authenticate a large collection of data
elements m_1,…,m_t and outsource them, along with the corresponding authenticators, to an untrusted
server. At any later point, the server can generate a
short authenticator sigma_(f,y) vouching for the correctness
of the output y of a function f computed on the outsourced data, i.e., y  = f(m_1,…,m_t). 
Recently researchers have focused on HAs as a solution, with minimal communication and interaction, to the
problem of delegating computation on outsourced data. The notion of HAs studied so far, however,
only  supports  executions  (and  proofs  of  correctness)  of  computations  over  data  authenticated  by  a
single  user.  Motivated  by  realistic  scenarios  (ubiquitous  computing,  sensor  networks,  etc.)  in  which
large datasets include data provided by multiple users, we study the concept of
multi-key homomorphic authenticators. 
In a nutshell, multi-key HAs are like HAs with the extra feature of allowing the holder
of public evaluation keys to compute on data authenticated under different secret keys. In this paper,
we introduce and formally define multi-key HAs. Secondly, we propose a construction of a multi-key
homomorphic signature based on standard lattices and supporting the evaluation of circuits of bounded
polynomial  depth.  Thirdly,  we  provide  a  construction  of  multi-key  homomorphic  MACs  based  only
on  pseudorandom  functions  and  supporting  the  evaluation  of  low-degree  arithmetic  circuits.  Albeit
being less expressive and only secretly verifiable, the latter construction presents interesting efficiency
properties.&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Apr 2019 16:00:00 +0200</pubDate>
        <link>/publications/2019/multi-key-HA-j</link>
        <guid isPermaLink="true">/publications/2019/multi-key-HA-j</guid>
        
        
        <category>journal</category>
        
      </item>
    
  </channel>
</rss>
